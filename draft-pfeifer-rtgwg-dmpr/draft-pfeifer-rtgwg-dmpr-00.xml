<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
        <!-- One method to get references from the online citation libraries.
            There has to be one entity for each item to be referenced.
            An alternate method (rfc include) is described in the references. -->

        <!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
        <!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
        <!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
        <!ENTITY RFC5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
        ]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->

<?rfc toc="yes"?>
<!-- generate a ToC -->

<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->

<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="info" docName="draft-pfeifer-rtgwg-dmpr-00" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
        or pre5378Trust200902
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <title abbrev="Dynamic MultiPath Routing">Dynamic MultiPath Routing
      Protocol
    </title>

    <author fullname="Hagen Paul Pfeifer" initials="H.P.P" role="editor"
            surname="Pfeifer">
      <organization>ProtocolLabs</organization>

      <address>
        <postal>
          <street>Agnes Bernauer Str. 84</street>
          <city>Munich</city>
          <code>80687</code>
          <country>DE</country>
        </postal>
        <phone>+49 174 54 55 209</phone>

        <email>hagen@jauu.net</email>
        <uri>http://www.jauu.net/</uri>
      </address>
    </author>


    <author fullname="Joshua Schueler" initials="J.S." surname="Schueler">
      <organization></organization>

      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country></country>
        </postal>
        <phone></phone>

        <email></email>
      </address>
    </author>

    <date year="2017"/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
    in the current day and month for you. If the year is not the current one, it is
    necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
    purpose of calculating the expiry date).  With drafts it is normally sufficient to
    specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>IETF</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
    If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>template</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>Insert an abstract: MANDATORY. This template is for creating an
        Internet Draft.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>this is dmpr, why we built it and what it can be used for</t>
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
          "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
          document are to be interpreted as described in <xref
                  target="RFC2119">RFC 2119</xref>.
        </t>
      </section>
      <section title="Terminology">
        <t>The following list describes the Terminology used in this RFC</t>
        <t>
          <list style="hanging">
            <t hangText="Router, Node">
              <vspace blankLines="0"/>
              A Router (or a Node) are the routing entities of a network which
              run an implementation of DMPR, have zero or more networks attached
              and at least one link to another router.
            </t>
            <t hangText="Link">
              <vspace blankLines="0"/>
              A Link is the direct connection between two interfaces of two
              distinct routers.
            </t>
            <t hangText="Link Attribute">
              <vspace blankLines="0"/>
              A Link Attribute is a basic attribute of a link, for example the
              maximum bandwidth, the average packet loss or the cost of the
              link.
            </t>
            <t hangText="Policy">
              <vspace blankLines="0"/>
              A Policy describes an order relation over a set of paths using the
              link attributes of these paths. Note that to guarantee loop-free
              properties this ordering function MUST be commutative and
              associative.
            </t>
          </list>
        </t>
      </section>
      <section title="Organization of this Document">
        <t>
          Section 2 describes the information every node has and gets and how it
          should proceed with that. Implementations are not required to strictly
          implement them as described here but the same functionality must be
          provided.
          Section 3 describes the behavior of the protocol in different
          scenarios and how it achieves particular features.
          Section 4 describes the message format in detail.
          Section 5 describes optional features which can be implemented to
          improve or extend DMPR but are not required for the basic
          functionality of propagating routing information.
        </t>
        <t>
          Appendix A has a few policy examples.
          Appendix B lists all constants used in this RFC where some of them are
          configurable.
          Appendix C shows a few simple examples of how DMPR behaves in specific
          network conditions.
        </t>
      </section>
      <section title="Overview">
        <t>
          Every router periodically sends out a multicast message to all its
          neighbors. This message includes the best path to each node known by
          this router. A router receiving this message adds itself to all these
          paths,
          chooses the best path to each node among all it got from its neighbors
          and itself advertises these paths via multicast messages. This is
          standard procedure in a Path-Vector Routing Protocol. In DMPR the
          paths are further separated by a policy, therefore it is possible to
          have more than one path to each node. Also included in the message are
          all attributes of this path so that the receiving node can make
          informed decisions on whether this path is the best under the current
          policy. In the end there exist multiple paths through the network and
          packets can be routed according to their requirements which for
          example can be the path with the highest bandwidth or with the lowest
          latency.
        </t>
      </section>
      <section title="Distinction from other Routing Protocols">
        <t>
          Traditionally, routing protocols find the best path using a scalar metric.
          This metric may be a simple constant stating the preference of the
          link or may be a computed metric using several factors like bandwidth,
          latency or cost. Furthermore, this metric is only known locally or,
          for example in the case of BGP-4, where external paths can be marked
          with a local preference for internal peers, to a small subset of the
          network.
          In DMPR a policy is a globally defined function which provides a
          ordering over paths. For this the policy has all link attributes of
          each path at its disposal and has a higher control over which path it
          chooses.
        </t>
      </section>
    </section>
    <section title="Data Structures">
      <t>Every router uses these data structures as Routing and Forward
        Information Base
      </t>
    </section>
    <section title="Behavior">
      <section title="Neighbor Detection">
        <t>
          Each node listens on the multicast address TODO. Periodically, after a
          defined message interval + jitter, a node sends out message which
          includes:
          <list style="symbols">
            <t>All nodes it has a path to, including the networks they
              advertise
            </t>
            <t>For each policy, a path to each node it knows of.</t>
            <t>The attributes of the links between the paths.</t>
          </list>
          When a node receives a message it deduces a connection and therefore a
          path to the sender via the interface that message came in. Through
          this mechanism the path to a node propagates through the network. To
          detect disconnected links or nodes getting removed or out of range, a
          node assigns every received message to a hold timer and purges this
          message after the timer expires.
          Asymmetric links are handled with a feature called reflection, this is
          described in TODO ref
        </t>
      </section>
      <section title="Interface Handling">
        <t>How do we handle multiple interfaces</t>
      </section>
      <section title="Message Handling">
        <t>how do we process the messages from neighbors</t>
      </section>
      <section title="Policies">
        <t>how do the policies come into the play</t>
      </section>
      <section title="Route Selection">
        <t>how do we select the best route</t>
      </section>
      <section title="Network Retraction">
        <t>what happens with retracted networks</t>
      </section>
      <section title="Other...">
        <t>TODO: how does the network handle: different network conditions,
          disappearing and reappearing nodes,
        </t>
      </section>
    </section>
    <section title="Message Format">
      <section title="Header">
        <t>A DMPR packet consists of a preamble, followed by zero or more
          Extension Headers followed by zero or one Payload. Each Extension
          Header and Payload is defined by a Type.
        </t>
        <texttable anchor="nexttype_table" title="Possible Types">
          <ttcol align="center">Type</ttcol>
          <ttcol align="left">Use</ttcol>

          <c>0-119</c>
          <c>Extension Header</c>

          <c>120-127</c>
          <c>Extension Header, reserved for private use</c>

          <c>128-247</c>
          <c>Payload</c>

          <c>248-255</c>
          <c>Payload, reserved for private use</c>

          <postamble>Possible Types are further defined below</postamble>
        </texttable>
        <section title="Preamble">
          <t>The preamble of a DMPR packet is as follows</t>
          <!-- Magic:3,Reserved:5,NextType:8,Payload:80 -->
          <figure align="center">
            <artwork align="left"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Magic| Reserved|    NextType   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
            <postamble>The preamble of a packet</postamble>
          </figure>
          <t>
            <list style="hanging">
              <t hangText="Magic">
                <vspace blankLines="0"/>
                A 3-bit Magic: 0b010
              </t>
              <t hangText="Reserved">
                <vspace blankLines="0"/>
                Reserved for future use
              </t>
              <t hangText="NextType">
                <vspace blankLines="0"/>
                The type of the next header or payload.
              </t>
            </list>
          </t>
        </section>
        <section title="Extension Header">
          <t>An Extension Header consists of the type immediately following this
            header, a length specifier, and the Extension Header data.
          </t>
          <!-- NextType:8,Length:8,Data:80 -->
          <figure align="center">
            <artwork align="left"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    NextType   |     Length    |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                              Data                             +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>
          <t>
            <list style="hanging">
              <t hangText="NextType">
                <vspace blankLines="0"/>
                The type of the immediately following header or payload (as
                specified in the packet preamble description)
              </t>
              <t hangText="Length">
                <vspace blankLines="0"/>
                8-bit unsigned integer: The length of the Data field in 2-octets
              </t>
              <t hangText="Data">
                <vspace blankLines="0"/>
                The header-specific data.
              </t>
            </list>
          </t>
        </section>
        <section title="Payload">
          <t>The Payload consists of the data until the end of the packet.
            Payloads may be recursive, i.e. contain a valid packet (or parts of
            it) in themselves, payload processors therefore MUST have the
            ability to feed their result back into the message processing chain.
          </t>
          <section title="Payload: Keep-Alive">
            <t>Type: 128</t>
            <t>This is a keep-alive packet, the payload length is zero.
              Implementations SHOULD reset the message hold timer for the
              sending node upon receiving a keep-alive packet
            </t>
          </section>
          <section title="Payload: Compressed JSON">
            <t>Type: 129</t>
            <t>LZMA-compressed standard-compliant JSON data (TODO RFC 7159)
              This is the main routing data, its structure is defined TODO: ref
            </t>
          </section>
          <section title="Payload: Fragmentation">
            <t>Type: 130</t>
            <t>A packet greater than the MTU between two nodes SHOULD be
              fragmented using the fragmentation payload.
            </t>
            <!-- Identifier:8,Last:1,Packet offset:7,Payload:48 -->
            <figure align="center">
              <artwork align="left"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Identifier  |L|Packet offset|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              <postamble>The Fragmentation Payload Header</postamble>
            </figure>
            <t>
              <list style="hanging">
                <t hangText="Identifier">
                  <vspace blankLines="0"/>
                  Identifies possibly concurrent fragmented packets.
                  Implementations SHOULD use an incrementing counter to
                  practically eliminate the possibility of a collision.
                </t>
                <t hangText="L(ast)">
                  <vspace blankLines="0"/>
                  Last, set to 1 if this packet has the highest packet offset
                  in this fragmentation collection, i.e. is the last packet.
                </t>
                <t hangText="Packet index">
                  <vspace blankLines="0"/>
                  7-bit unsigned integer. Defines the index of this packet in
                  the list of fragments resulting in the fragmentation of the
                  original packet. The first packet has offset zero.
                </t>
              </list>
            </t>
            <t>When a packet is larger than the MTU of the link between two
              nodes it SHOULD be fragmented. For this the sending node computes
              the maximum effective payload size for packets sent (i.e MTU less
              preamble, possibly extension headers and the fragmentation header)
              and splits the original packet into parts with this size. For each
              of this parts it sends a packet with the fragmentation header set
              to a common Identifier, an according packet offset and the LAST
              bit set for the last fragment.
            </t>
            <t>The receiving node keeps track of all received fragments,
              grouping them by source address and Identifier. As soon as a all
              fragments of a packet have been received, the reconstructed packet
              MUST be fed back into the message processing chain as if it were a
              new, just received packet. Fragments MUST be regularly purged
              based on a hold timer.
            </t>
          </section>
        </section>
      </section>
      <section title="JSON Payload">
        <t>A JSON payload is a lzma-compressed, ascii-7 encoded JSON object.
          A sending node SHOULD use ascii-encoding for the json data, a
          receiving node MUST be able to decode UTF-8 encoded data.
        </t>
        <t>Augmented requirements language for this section:
          <list style="hanging">
            <t hangText="REQUIRED">
              <vspace blankLines="0"/>
              This field is required, the sending node MUST include it.
            </t>
            <t hangText="REQUIRED if not empty">
              <vspace blankLines="0"/>
              If the field would be empty, it can be omitted, otherwise it is
              REQUIRED
            </t>
            <t hangText="OPTIONAL">
              <vspace blankLines="0"/>
              This field can be inserted to activate specific features or use
              other functionality. A sending node can choose to omit it and a
              receiving node MUST be able to work without this field.
            </t>
          </list>
        </t>
        <t>
          <figure>
            <preamble>General Message Structure</preamble>
            <artwork><![CDATA[
{
  "id": <NODE_ID>,
  "seq": <SEQUENCE_NUMBER>,
  "type": <TYPE>,
  "partial-base": <SEQUENCE_NUMBER>,

  "addr-v4": <IPv4_ADDRESS>,
  "addr-v6": <IPv6_ADDRESS>,
  "networks": {
    <IPvX_NETWORK>: {},
    <IPvX_NETWORK>: {
      "retracted": true
    }
  },
  "routing-data": {
    <POLICY>: {
      <NODE_ID>: {
        "path": <PATH>
      }
    }
  },
  "node-data": {
    <NODE_ID>: {
      "networks": {
        <IPvX_NETWORK>: {},
        <IPvX_NETWORK>: {
          "retracted": true
        }
      }
    }
  },
  "link-attributes": {
    <LINK_ATTRIBUTE_ID>: {
      <LINK_ATTRIBUTE>: <METRIC>
    }
  },

  "request-full": union(true, [<NODE_ID>, ...]),

  "reflect": {
    <REFLECT_DATA>: <DATA>
  }

  "reflected": {
    <NODE_ID>: {
      <REFLECT_DATA>: <DATA>
    }
  }
}
            ]]></artwork>
          </figure>
        </t>
        <t>Key and value description:
          <list style="hanging">
            <t hangText="id">
              <vspace blankLines="0"/>
              string: The sending node's id, NODE_ID: MUST NOT contain any of
              the brackets: ()[]{}&lt;&gt;
            </t>
            <t hangText="seq">
              <vspace blankLines="0"/>
              integer: The message sequence number, strictly monotonically
              increasing
            </t>
            <t hangText="type">
              <vspace blankLines="0"/>
              string: The type of the message, further specified below TODO ref
            </t>
            <t hangText="partial-base">
              <vspace blankLines="0"/>
              integer: The base message of a partial update, the message then
              only
              includes the difference between the actual data and the base
              message
            </t>
            <t hangText="addr-v4">
              <vspace blankLines="0"/>
              string: The IPv4 address of the sending node over the link this
              packet has been sent.
            </t>
            <t hangText="addr-v6">
              <vspace blankLines="0"/>
              string: The IPv6 address of the sending node over the link this
              packet has been sent.
            </t>
            <t hangText="networks">
              <vspace blankLines="0"/>
              object: The networks advertised by this node. The keys are valid
              IPv4/IPv6 Network identifications with subnet prefix. If the value
              of a network key is a object itself and the key "retracted" of
              this object is set to true, the network MUST be handled as
              retracted, see TODO ref retraction
            </t>
            <t hangText="routing-data">
              <vspace blankLines="0"/>
              object: A path to each reachable node for each policy. POLICY is
              the name of a policy defined in the sending node. If the receiving
              node does not understand this policy the entry MUST be ignored.
              PATH: a path to a node described according to this syntax:
              <figure>
                <artwork type="abnf"><![CDATA[
path = node [node-id ">[" link-attribute-id "]>" path]
node-id = *ALPHA
link-attribute-id = *DIGIT
              ]]></artwork>
              </figure>
            </t>
            <t hangText="node-data">
              <vspace blankLines="0"/>
              object: a list of networks for each reachable node defined in
              "routing-data". "networks" is handled like "networks" defined
              above
            </t>
            <t hangText="link-attributes">
              <vspace blankLines="0"/>
              object: the set of link-attributes used in the paths of
              routing-data. Each key SHOULD be an integer and MUST NOT contain
              any of the brackets ()[]{}&lt;&gt;
              the value of a entry is itself a object containing LINK_ATTRIBUTE:
              METRIC pairs where LINK_ATTRIBUTE is the name of a link attribute
              and metric is its value as defined in Terminology TODO ref
            </t>
            <t hangText="request-full">
              <vspace blankLines="0"/>
              array or true: A list of NODE_IDs from which the sending node
              requests a full update message.
              If true the node requests a full update from all neighbors.
            </t>
            <t hangText="reflect">
              <vspace blankLines="0"/>
              object: arbitrary data the sending node wants to have included in
              the "reflected" object in the next message of the receiver
            </t>
            <t hangText="reflected">
              <vspace blankLines="0"/>
              object: a set of reflected data, contains, for each neighboring
              node the data the node requested to reflect.
            </t>
          </list>
        </t>
        <section title="Full Update">
          <t>A full update SHOULD replace all data from the sending node in the
            receivers Message Information Base, it MUST NOT require any previous
            knowledge of the sender by the receiver. The following keys are
            specified:
          </t>
          <t>
            <list style="hanging">
              <t hangText="addr-v4">
                <vspace blankLines="0"/>
                string, REQUIRED: The IPv4 address of the
                sending node over the link this packet has been sent.
              </t>
              <t hangText="addr-v6">
                <vspace blankLines="0"/>
                string: REQUIRED: The IPv6 address of the
                sending node over the link this packet has been sent.
              </t>
              <t>Note: only one of addr-v4 and addr-v6 is required</t>
              <t hangText="networks">
                <vspace blankLines="0"/>
                object, REQUIRED if not empty: The networks
                advertised by this node, see above
              </t>
              <t hangText="routing-data">
                <vspace blankLines="0"/>
                object, REQUIRED if not empty: The paths advertised by the
                sender, grouped by POLICY and target NODE_ID. The syntax of a
                path is described above. A path MUST include the sender of this
                message, all hops with their link-attribute ids and the target
                node.
              </t>
              <t hangText="node-data">
                <vspace blankLines="0"/>
                object, OPTIONAL: The networks from other nodes known to the
                sender including their retraction status.
              </t>
              <t hangText="link-attributes">
                <vspace blankLines="0"/>
                object, REQUIRED if not empty: The link-attributes used in
                "routing-data". Each entry MUST contain all attributes known to
                the sender, even if they are not needed by a policy.
              </t>
              <!-- TODO -->
            </list>
          </t>
        </section>
        <section title="Partial Update">
          <t>A partial update only replaces the changed data in the receivers
            Message Information Base. It therefore has the additional field
            "partial-base" which describes the sequence number of the base
            message, which MUST be a full update message, on which the changes
            apply. NOTE: A partial update only describes changes to a previous
            full update, never to a previous partial update. The following keys
            are specified:
          </t>
          <t>
            <list style="hanging">
              <t hangText="addr-v4">
                <vspace blankLines="0"/>
                string, OPTIONAL: The IPv4 address of the sending node over the
                link this packet has been sent, only included if it has not
                changed. If it became invalid, the value is null.
              </t>
              <t hangText="addr-v6">
                <vspace blankLines="0"/>
                string, OPTIONAL: The IPv6 address of the sending node over the
                link this packet has been sent, only included if it has not
                changed. If it became invalid, the value is null.
              </t>
              <t>NOTE: A partial update MUST NOT produce an invalid
                configuration by deleting the only address available for a node.
              </t>
              <t hangText="networks">
                <vspace blankLines="0"/>
                object, OPTIONAL: The networks advertised by the sender. The
                entries replace the base message entries on a per
                NODE_ID basis. If a entry has been deleted, the value for the
                specific NODE_ID is null.
              </t>
              <t hangText="routing-data">
                <vspace blankLines="0"/>
                object, OPTIONAL: The paths advertised by the sender, grouped by
                POLICY and target NODE_ID. The entries replace the base message
                entries on a per NODE_ID basis. If a entry has been deleted, the
                value for the specific NODE_ID is null.
              </t>
              <t hangText="node-data">
                <vspace blankLines="0"/>
                object, OPTIONAL: The networks from other nodes known to the
                sender. The entries replace the base message entries on a per
                NODE_ID basis. If a entry has been deleted, the value for the
                specific NODE_ID is null.
              </t>
              <t hangText="link-attributes">
                <vspace blankLines="0"/>
                object, REQUIRED if not empty: The link-attributes used in
                "routing-data". Note that link-attributes are only valid on a
                per-message basis and MUST NOT replace link-attribute entries in
                the base message.
              </t>
              <!-- TODO -->
            </list>
          </t>
        </section>
        <section title="Keep Alive">
          <t>keepalive</t>
        </section>
      </section>
      <section title="Requests">
        <t>fields and description of full-update requests</t>
      </section>
      <section title="Reflections">
        <t>fields and description of reflections</t>
      </section>
    </section>
    <section title="Optional Features">
      <section title="Asymmetric Link Detection">
        <t>How should asymmetric link detection work/how can it be implemented
        </t>
      </section>
      <section title="Full Only Mode">
        <t>when/how to switch the mode</t>
      </section>
    </section>
    <section title="Introduction">
      <t>The original specification of xml2rfc format is in <xref
              target="RFC2629">RFC&nbsp;2629</xref>.
      </t>
    </section>

    <section anchor="simple_list" title="Simple List">
      <t>List styles: 'empty', 'symbols', 'letters', 'numbers', 'hanging',
        'format'.
      </t>

      <t>
        <list style="symbols">
          <t>First bullet</t>

          <t>Second bullet</t>
        </list>
        You can write text here as well.
      </t>
    </section>

    <!-- This PI places the pagebreak correctly (before the section title) in the text output. -->

    <?rfc needLines="8" ?>

    <section anchor="nested_lists" title="More about Lists">
      <t>Lists with 'hanging labels': the list item is indented the amount of
        the hangIndent:
        <list hangIndent="8" style="hanging">
          <t hangText="short">With a label shorter than the hangIndent.</t>

          <t hangText="fantastically long label">With a label longer than the
            hangIndent.
          </t>

          <t hangText="vspace_trick"><vspace blankLines="0"/>Forces the new
            item to start on a new line.
          </t>
        </list>
      </t>

      <!-- It would be nice to see the next piece (12 lines) all on one page. -->

      <?rfc needLines="12" ?>

      <t>Simulating more than one paragraph in a list item using
        &lt;vspace&gt;:
        <list style="letters">
          <t>First, a short item.</t>

          <t>Second, a longer list item.
            <vspace blankLines="1"/>
            And
            something that looks like a separate pararaph..
          </t>
        </list>
      </t>

      <t>Simple indented paragraph using the "empty" style:
        <list
                hangIndent="10" style="empty">
          <t>The quick, brown fox jumped over the lazy dog and lived to fool
            many another hunter in the great wood in the west.
          </t>
        </list>
      </t>

      <section title="Numbering Lists across Lists and Sections">
        <t>Numbering items continuously although they are in separate
          &lt;list&gt; elements, maybe in separate sections using the "format"
          style and a "counter" variable.
        </t>

        <t>First list:
          <list counter="reqs" hangIndent="4" style="format R%d">
            <t>#1</t>

            <t>#2</t>

            <t>#3</t>
          </list>
          Specify the indent explicitly so that all the items line up
          nicely.
        </t>

        <t>Second list:
          <list counter="reqs" hangIndent="4" style="format R%d">
            <t>#4</t>

            <t>#5</t>

            <t>#6</t>
          </list>
        </t>
      </section>

      <section title="Where the List Numbering Continues">
        <t>List continues here.</t>

        <t>Third list:
          <list counter="reqs" hangIndent="4" style="format R%d">
            <t>#7</t>

            <t>#8</t>

            <t>#9</t>

            <t>#10</t>
          </list>
          The end of the list.
        </t>
      </section>
    </section>

    <section anchor="codeExample"
             title="Example of Code or MIB Module To Be Extracted">
      <figure>
        <preamble>The &lt;artwork&gt; element has a number of extra attributes
          that can be used to substitute a more aesthetically pleasing rendition
          into HTML output while continuing to use the ASCII art version in the
          text and nroff outputs (see the xml2rfc README for details). It also
          has a "type" attribute. This is currently ignored except in the case
          'type="abnf"'. In this case the "artwork" is expected to contain a
          piece of valid Augmented Backus-Naur Format (ABNF) grammar. This will
          be syntax checked by xml2rfc and any errors will cause a fatal error
          if the "strict" processing instruction is set to "yes". The ABNF will
          also be colorized in HTML output to highlight the syntactic
          components. Checking of additional "types" may be provided in future
          versions of xml2rfc.
        </preamble>

        <artwork><![CDATA[

/**** an example C program */

#include <stdio.h>

void
main(int argc, char *argv[])
{
   int i;

   printf("program arguments are:\n");
   for (i = 0; i < argc; i++) {
       printf("%d: \"%s\"\n", i, argv[i]);
   }

   exit(0);
} /* main */

/* end of file */

           ]]></artwork>
      </figure>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>This template was derived from an initial version written by Pekka
        Savola and contributed by him to the xml2rfc project.
      </t>

      <t>This document is part of a plan to make xml2rfc indispensable <xref
              target="DOMINATION"></xref>.
      </t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>

      <t>All drafts are required to have an IANA considerations section (see
        <xref target="RFC5226">Guidelines for Writing an IANA Considerations
          Section in RFCs
        </xref>
        for a guide). If the draft does not require IANA to do
        anything, the section contains an explicit statement that this is the
        case (as above). If there are no requirements for IANA, the section will
        be removed during conversion into an RFC by the RFC Editor.
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>All drafts are required to have a security considerations section.
        See <xref target="RFC3552">RFC 3552</xref> for a guide.
      </t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2119;

      <reference anchor="min_ref">
        <!-- the following is the minimum to make xml2rfc happy -->

        <front>
          <title>Minimal Reference</title>

          <author initials="authInitials" surname="authSurName">
            <organization></organization>
          </author>

          <date year="2006"/>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC2629;

      &RFC3552;

      &RFC5226;

      <!-- A reference written by by an organization not a person. -->

      <reference anchor="DOMINATION"
                 target="http://www.example.com/dominator.html">
        <front>
          <title>Ultimate Plan for Taking Over the World</title>

          <author>
            <organization>Mad Dominators, Inc.</organization>
          </author>

          <date year="1984"/>
        </front>
      </reference>
    </references>

    <section title="Policies">
      <t>many exchangeable policies</t>
      <section title="Low Loss Policy">
        <t>use path with lowest overall loss</t>
      </section>
      <section title="High Bandwidth Policy">
        <t>use path with highest bandwidth</t>
      </section>
    </section>
    <section title="Tuneables">
      <t>The different magic values and what they affect, how they could/should
        be
        set
      </t>
    </section>
    <section title="Examples">
      <t>Examples</t>
    </section>
  </back>
</rfc>
